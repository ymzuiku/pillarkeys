{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/roughjs/src/generator.js","webpack://exports/./node_modules/roughjs/src/hachure.js","webpack://exports/./node_modules/roughjs/src/path.js","webpack://exports/./node_modules/roughjs/src/renderer.js","webpack://exports/./node_modules/roughjs/src/segment.js","webpack://exports/./src/my-command.js","webpack://exports/./src/roughjs.js","webpack://exports/external \"sketch\""],"names":["getPathFromLayer","layer","nsbezierpath","NSBezierPath","bezierPathWithPath","sketchObject","pathInFrameWithTransforms","String","svgPathAttribute","replace","getOptionsFromLayer","options","fill","style","fills","filter","f","isEnabled","color","border","borders","fillType","stroke","strokeWidth","thickness","context","document","sketch","getSelectedDocument","selection","selectedLayers","isEmpty","forEach","type","rc","parent","newLayer","path","name","hidden","selected","RoughSketch","config","fromNative","_init","gen","frame","x1","y1","x2","y2","d","line","draw","x","y","width","height","rectangle","ellipse","diameter","circle","points","linearPath","polygon","start","stop","closed","arc","curve","drawing","drawable","sets","o","defaultOptions","group","Group","MOPointer","alloc","init","Shape","MSShapeGroup","shapeWithBezierPath","MSPath","pathWithBezierPath","SVGPathInterpreter","bezierPathFromCommands_isPathClosed","_opsToPath","_fillSketch","size","mask","hash","hasClippingMask","clippingMaskMode","adjustToFit","fweight","fillWeight","opsToPath"],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;ACnEwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,MAAM,eAAe,GAAG,6CAA6C;AACzH;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,GAAG,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ,GAAG,QAAQ;AACzC;AACA;AACA,sBAAsB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,GAAG,QAAQ,IAAI,QAAQ,GAAG,QAAQ;AACvF;AACA;AACA,sBAAsB,QAAQ,GAAG,QAAQ,IAAI,QAAQ,GAAG,QAAQ;AAChE;AACA;AACA,sBAAsB,QAAQ,GAAG,QAAQ;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,cAAc;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACja6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACxEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;AC7b+B;AACc;AACM;;AAEnD;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,kBAAkB,+BAA+B;AACjD,kBAAkB,2EAA2E;AAC7F;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yHAAyH;AAC3I,uBAAuB,SAAS;AAChC,oBAAoB,2HAA2H;AAC/I;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,kBAAkB,qCAAqC;AACvD,OAAO;AACP,kBAAkB,iHAAiH;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qHAAqH;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,oBAAoB,qHAAqH;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qHAAqH;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,oBAAoB,qHAAqH;AACzI;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA,kBAAkB,+EAA+E;AACjG;AACA;AACA;AACA;AACA,kBAAkB,oHAAoH;AACtI;AACA,KAAK;AACL,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACzsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAC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","file":"my-command.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/my-command.js\");\n","import { RoughRenderer } from './renderer.js';\nself._roughScript = self.document && self.document.currentScript && self.document.currentScript.src;\n\nexport class RoughGenerator {\n  constructor(config, canvas) {\n    this.config = config || {};\n    this.canvas = canvas;\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveStepCount: 9,\n      fill: null,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1\n    };\n    if (this.config.options) {\n      this.defaultOptions = this._options(this.config.options);\n    }\n  }\n\n  _options(options) {\n    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n  }\n\n  _drawable(shape, sets, options) {\n    return { shape, sets: sets || [], options: options || this.defaultOptions };\n  }\n\n  get lib() {\n    if (!this._renderer) {\n      if (self && self.workly && this.config.async && (!this.config.noWorker)) {\n        const tos = Function.prototype.toString;\n        const worklySource = this.config.worklyURL || 'https://cdn.jsdelivr.net/gh/pshihn/workly/dist/workly.min.js';\n        const rendererSource = this.config.roughURL || self._roughScript;\n        if (rendererSource && worklySource) {\n          let code = `importScripts('${worklySource}', '${rendererSource}');\\nworkly.expose(self.rough.createRenderer());`;\n          let ourl = URL.createObjectURL(new Blob([code]));\n          this._renderer = workly.proxy(ourl);\n        } else {\n          this._renderer = new RoughRenderer();\n        }\n      } else {\n        this._renderer = new RoughRenderer();\n      }\n    }\n    return this._renderer;\n  }\n\n  line(x1, y1, x2, y2, options) {\n    const o = this._options(options);\n    return this._drawable('line', [this.lib.line(x1, y1, x2, y2, o)], o);\n  }\n\n  rectangle(x, y, width, height, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (o.fill) {\n      const xc = [x, x + width, x + width, x];\n      const yc = [y, y, y + height, y + height];\n      if (o.fillStyle === 'solid') {\n        paths.push(this.lib.solidFillShape(xc, yc, o))\n      } else {\n        paths.push(this.lib.hachureFillShape(xc, yc, o));\n      }\n    }\n    paths.push(this.lib.rectangle(x, y, width, height, o));\n    return this._drawable('rectangle', paths, o);\n  }\n\n  ellipse(x, y, width, height, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = this.lib.ellipse(x, y, width, height, o);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(this.lib.hachureFillEllipse(x, y, width, height, o));\n      }\n    }\n    paths.push(this.lib.ellipse(x, y, width, height, o));\n    return this._drawable('ellipse', paths, o);\n  }\n\n  circle(x, y, diameter, options) {\n    let ret = this.ellipse(x, y, diameter, diameter, options);\n    ret.shape = 'circle';\n    return ret;\n  }\n\n  linearPath(points, options) {\n    const o = this._options(options);\n    return this._drawable('linearPath', [this.lib.linearPath(points, false, o)], o);\n  }\n\n  polygon(points, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (o.fill) {\n      let xc = [], yc = [];\n      for (let p of points) {\n        xc.push(p[0]);\n        yc.push(p[1]);\n      }\n      if (o.fillStyle === 'solid') {\n        paths.push(this.lib.solidFillShape(xc, yc, o));\n      } else {\n        paths.push(this.lib.hachureFillShape(xc, yc, o));\n      }\n    }\n    paths.push(this.lib.linearPath(points, true, o));\n    return this._drawable('polygon', paths, o);\n  }\n\n  arc(x, y, width, height, start, stop, closed, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (closed && o.fill) {\n      if (o.fillStyle === 'solid') {\n        let shape = this.lib.arc(x, y, width, height, start, stop, true, false, o);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(this.lib.hachureFillArc(x, y, width, height, start, stop, o));\n      }\n    }\n    paths.push(this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n    return this._drawable('arc', paths, o);\n  }\n\n  curve(points, options) {\n    const o = this._options(options);\n    return this._drawable('curve', [this.lib.curve(points, o)], o);\n  }\n\n  path(d, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (!d) {\n      return this._drawable('path', paths, o);\n    }\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        let shape = { type: 'path2Dfill', path: d };\n        paths.push(shape);\n      } else {\n        const size = this._computePathSize(d);\n        let xc = [0, size[0], size[0], 0];\n        let yc = [0, 0, size[1], size[1]];\n        let shape = this.lib.hachureFillShape(xc, yc, o);\n        shape.type = 'path2Dpattern';\n        shape.size = size;\n        shape.path = d;\n        paths.push(shape);\n      }\n    }\n    paths.push(this.lib.svgPath(d, o));\n    return this._drawable('path', paths, o);\n  }\n\n  toPaths(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.defaultOptions;\n    const paths = [];\n    for (const drawing of sets) {\n      let path = null;\n      switch (drawing.type) {\n        case 'path':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: o.stroke,\n            strokeWidth: o.strokeWidth,\n            fill: 'none'\n          };\n          break;\n        case 'fillPath':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: 'none',\n            strokeWidth: 0,\n            fill: o.fill\n          };\n          break;\n        case 'fillSketch':\n          path = this._fillSketch(drawing, o);\n          break;\n        case 'path2Dfill':\n          path = {\n            d: drawing.path,\n            stroke: 'none',\n            strokeWidth: 0,\n            fill: o.fill\n          };\n          break;\n        case 'path2Dpattern': {\n          const size = drawing.size;\n          const pattern = {\n            x: 0, y: 0, width: 1, height: 1,\n            viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n            patternUnits: 'objectBoundingBox',\n            path: this._fillSketch(drawing, o)\n          };\n          path = {\n            d: drawing.path,\n            stroke: 'none',\n            strokeWidth: 0,\n            pattern: pattern\n          };\n          break;\n        }\n      }\n      if (path) {\n        paths.push(path);\n      }\n    }\n    return paths;\n  }\n\n  _fillSketch(drawing, o) {\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n    return {\n      d: this.opsToPath(drawing),\n      stroke: o.fill,\n      strokeWidth: fweight,\n      fill: 'none'\n    };\n  }\n\n  opsToPath(drawing) {\n    let path = '';\n    for (let item of drawing.ops) {\n      const data = item.data;\n      switch (item.op) {\n        case 'move':\n          path += `M${data[0]} ${data[1]} `;\n          break;\n        case 'bcurveTo':\n          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n          break;\n        case 'qcurveTo':\n          path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n          break;\n        case 'lineTo':\n          path += `L${data[0]} ${data[1]} `;\n          break;\n      }\n    }\n    return path.trim();\n  }\n\n  _computePathSize(d) {\n    let size = [0, 0];\n    if (self.document) {\n      try {\n        const ns = \"http://www.w3.org/2000/svg\";\n        let svg = self.document.createElementNS(ns, \"svg\");\n        svg.setAttribute(\"width\", \"0\");\n        svg.setAttribute(\"height\", \"0\");\n        let pathNode = self.document.createElementNS(ns, \"path\");\n        pathNode.setAttribute('d', d);\n        svg.appendChild(pathNode);\n        self.document.body.appendChild(svg);\n        let bb = pathNode.getBBox()\n        if (bb) {\n          size[0] = bb.width || 0;\n          size[1] = bb.height || 0;\n        }\n        self.document.body.removeChild(svg);\n      } catch (err) { }\n    }\n    const canvasSize = this._canvasSize();\n    if (!(size[0] * size[1])) {\n      size = canvasSize;\n    }\n    size[0] = Math.min(size[0], canvasSize[0]);\n    size[1] = Math.min(size[1], canvasSize[1]);\n    return size;\n  }\n\n  _canvasSize() {\n    const val = w => {\n      if (w) {\n        if (typeof w === 'object') {\n          if (w.baseVal && w.baseVal.value) {\n            return w.baseVal.value;\n          }\n        }\n      }\n      return w || 100;\n    };\n    return this.canvas ? [val(this.canvas.width), val(this.canvas.height)] : [100, 100];\n  }\n}\n\nexport class RoughGeneratorAsync extends RoughGenerator {\n  async line(x1, y1, x2, y2, options) {\n    const o = this._options(options);\n    return this._drawable('line', [await this.lib.line(x1, y1, x2, y2, o)], o);\n  }\n\n  async rectangle(x, y, width, height, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (o.fill) {\n      const xc = [x, x + width, x + width, x];\n      const yc = [y, y, y + height, y + height];\n      if (o.fillStyle === 'solid') {\n        paths.push(await this.lib.solidFillShape(xc, yc, o))\n      } else {\n        paths.push(await this.lib.hachureFillShape(xc, yc, o));\n      }\n    }\n    paths.push(await this.lib.rectangle(x, y, width, height, o));\n    return this._drawable('rectangle', paths, o);\n  }\n\n  async ellipse(x, y, width, height, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = await this.lib.ellipse(x, y, width, height, o);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(await this.lib.hachureFillEllipse(x, y, width, height, o));\n      }\n    }\n    paths.push(await this.lib.ellipse(x, y, width, height, o));\n    return this._drawable('ellipse', paths, o);\n  }\n\n  async circle(x, y, diameter, options) {\n    let ret = await this.ellipse(x, y, diameter, diameter, options);\n    ret.shape = 'circle';\n    return ret;\n  }\n\n  async linearPath(points, options) {\n    const o = this._options(options);\n    return this._drawable('linearPath', [await this.lib.linearPath(points, false, o)], o);\n  }\n\n  async polygon(points, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (o.fill) {\n      let xc = [], yc = [];\n      for (let p of points) {\n        xc.push(p[0]);\n        yc.push(p[1]);\n      }\n      if (o.fillStyle === 'solid') {\n        paths.push(await this.lib.solidFillShape(xc, yc, o));\n      } else {\n        paths.push(await this.lib.hachureFillShape(xc, yc, o));\n      }\n    }\n    paths.push(await this.lib.linearPath(points, true, o));\n    return this._drawable('polygon', paths, o);\n  }\n\n  async arc(x, y, width, height, start, stop, closed, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (closed && o.fill) {\n      if (o.fillStyle === 'solid') {\n        let shape = await this.lib.arc(x, y, width, height, start, stop, true, false, o);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(await this.lib.hachureFillArc(x, y, width, height, start, stop, o));\n      }\n    }\n    paths.push(await this.lib.arc(x, y, width, height, start, stop, closed, true, o));\n    return this._drawable('arc', paths, o);\n  }\n\n  async curve(points, options) {\n    const o = this._options(options);\n    return this._drawable('curve', [await this.lib.curve(points, o)], o);\n  }\n\n  async path(d, options) {\n    const o = this._options(options);\n    const paths = [];\n    if (!d) {\n      return this._drawable('path', paths, o);\n    }\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        let shape = { type: 'path2Dfill', path: d };\n        paths.push(shape);\n      } else {\n        const size = this._computePathSize(d);\n        let xc = [0, size[0], size[0], 0];\n        let yc = [0, 0, size[1], size[1]];\n        let shape = await this.lib.hachureFillShape(xc, yc, o);\n        shape.type = 'path2Dpattern';\n        shape.size = size;\n        shape.path = d;\n        paths.push(shape);\n      }\n    }\n    paths.push(await this.lib.svgPath(d, o));\n    return this._drawable('path', paths, o);\n  }\n}","import { RoughSegmentRelation, RoughSegment } from \"./segment\";\n\nexport class RoughHachureIterator {\n  constructor(top, bottom, left, right, gap, sinAngle, cosAngle, tanAngle) {\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n    this.gap = gap;\n    this.sinAngle = sinAngle;\n    this.tanAngle = tanAngle;\n\n    if (Math.abs(sinAngle) < 0.0001) {\n      this.pos = left + gap;\n    } else if (Math.abs(sinAngle) > 0.9999) {\n      this.pos = top + gap;\n    } else {\n      this.deltaX = (bottom - top) * Math.abs(tanAngle);\n      this.pos = left - Math.abs(this.deltaX);\n      this.hGap = Math.abs(gap / cosAngle);\n      this.sLeft = new RoughSegment(left, bottom, left, top);\n      this.sRight = new RoughSegment(right, bottom, right, top);\n    }\n  }\n\n  getNextLine() {\n    if (Math.abs(this.sinAngle) < 0.0001) {\n      if (this.pos < this.right) {\n        let line = [this.pos, this.top, this.pos, this.bottom];\n        this.pos += this.gap;\n        return line;\n      }\n    } else if (Math.abs(this.sinAngle) > 0.9999) {\n      if (this.pos < this.bottom) {\n        let line = [this.left, this.pos, this.right, this.pos];\n        this.pos += this.gap;\n        return line;\n      }\n    } else {\n      let xLower = this.pos - this.deltaX / 2;\n      let xUpper = this.pos + this.deltaX / 2;\n      let yLower = this.bottom;\n      let yUpper = this.top;\n      if (this.pos < (this.right + this.deltaX)) {\n        while (((xLower < this.left) && (xUpper < this.left)) || ((xLower > this.right) && (xUpper > this.right))) {\n          this.pos += this.hGap;\n          xLower = this.pos - this.deltaX / 2;\n          xUpper = this.pos + this.deltaX / 2;\n          if (this.pos > (this.right + this.deltaX)) {\n            return null;\n          }\n        }\n        let s = new RoughSegment(xLower, yLower, xUpper, yUpper);\n        if (s.compare(this.sLeft) == RoughSegmentRelation().INTERSECTS) {\n          xLower = s.xi;\n          yLower = s.yi;\n        }\n        if (s.compare(this.sRight) == RoughSegmentRelation().INTERSECTS) {\n          xUpper = s.xi;\n          yUpper = s.yi;\n        }\n        if (this.tanAngle > 0) {\n          xLower = this.right - (xLower - this.left);\n          xUpper = this.right - (xUpper - this.left);\n        }\n        let line = [xLower, yLower, xUpper, yUpper];\n        this.pos += this.hGap;\n        return line;\n      }\n    }\n    return null;\n  }\n}","class PathToken {\n  constructor(type, text) {\n    this.type = type;\n    this.text = text;\n  }\n  isType(type) {\n    return this.type === type;\n  }\n}\n\nclass ParsedPath {\n  constructor(d) {\n    this.PARAMS = {\n      A: [\"rx\", \"ry\", \"x-axis-rotation\", \"large-arc-flag\", \"sweep-flag\", \"x\", \"y\"],\n      a: [\"rx\", \"ry\", \"x-axis-rotation\", \"large-arc-flag\", \"sweep-flag\", \"x\", \"y\"],\n      C: [\"x1\", \"y1\", \"x2\", \"y2\", \"x\", \"y\"],\n      c: [\"x1\", \"y1\", \"x2\", \"y2\", \"x\", \"y\"],\n      H: [\"x\"],\n      h: [\"x\"],\n      L: [\"x\", \"y\"],\n      l: [\"x\", \"y\"],\n      M: [\"x\", \"y\"],\n      m: [\"x\", \"y\"],\n      Q: [\"x1\", \"y1\", \"x\", \"y\"],\n      q: [\"x1\", \"y1\", \"x\", \"y\"],\n      S: [\"x2\", \"y2\", \"x\", \"y\"],\n      s: [\"x2\", \"y2\", \"x\", \"y\"],\n      T: [\"x\", \"y\"],\n      t: [\"x\", \"y\"],\n      V: [\"y\"],\n      v: [\"y\"],\n      Z: [],\n      z: []\n    };\n    this.COMMAND = 0;\n    this.NUMBER = 1;\n    this.EOD = 2;\n    this.segments = [];\n    this.d = d || \"\";\n    this.parseData(d);\n    this.processPoints();\n  }\n\n  loadFromSegments(segments) {\n    this.segments = segments;\n    this.processPoints();\n  }\n\n  processPoints() {\n    let first = null, prev = null, currentPoint = [0, 0];\n    for (let i = 0; i < this.segments.length; i++) {\n      let s = this.segments[i];\n      switch (s.key) {\n        case 'M':\n        case 'L':\n        case 'T':\n          s.point = [s.data[0], s.data[1]];\n          break;\n        case 'm':\n        case 'l':\n        case 't':\n          s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n          break;\n        case 'H':\n          s.point = [s.data[0], currentPoint[1]];\n          break;\n        case 'h':\n          s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n          break;\n        case 'V':\n          s.point = [currentPoint[0], s.data[0]];\n          break;\n        case 'v':\n          s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n          break;\n        case 'z':\n        case 'Z':\n          if (first) {\n            s.point = [first[0], first[1]];\n          }\n          break;\n        case 'C':\n          s.point = [s.data[4], s.data[5]];\n          break;\n        case 'c':\n          s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n          break;\n        case 'S':\n          s.point = [s.data[2], s.data[3]];\n          break;\n        case 's':\n          s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n          break;\n        case 'Q':\n          s.point = [s.data[2], s.data[3]];\n          break;\n        case 'q':\n          s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n          break;\n        case 'A':\n          s.point = [s.data[5], s.data[6]];\n          break;\n        case 'a':\n          s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n          break;\n      }\n      if (s.key === 'm' || s.key === 'M') {\n        first = null;\n      }\n      if (s.point) {\n        currentPoint = s.point;\n        if (!first) {\n          first = s.point;\n        }\n      }\n      if (s.key === 'z' || s.key === 'Z') {\n        first = null;\n      }\n      prev = s;\n    }\n  }\n\n  get closed() {\n    if (typeof this._closed === 'undefined') {\n      this._closed = false;\n      for (let s of this.segments) {\n        if (s.key.toLowerCase() === 'z') {\n          this._closed = true;\n        }\n      }\n    }\n    return this._closed;\n  }\n\n  parseData(d) {\n    var tokens = this.tokenize(d);\n    var index = 0;\n    var token = tokens[index];\n    var mode = \"BOD\";\n    this.segments = new Array();\n    while (!token.isType(this.EOD)) {\n      var param_length;\n      var params = new Array();\n      if (mode == \"BOD\") {\n        if (token.text == \"M\" || token.text == \"m\") {\n          index++;\n          param_length = this.PARAMS[token.text].length;\n          mode = token.text;\n        } else {\n          return this.parseData('M0,0' + d);\n        }\n      } else {\n        if (token.isType(this.NUMBER)) {\n          param_length = this.PARAMS[mode].length;\n        } else {\n          index++;\n          param_length = this.PARAMS[token.text].length;\n          mode = token.text;\n        }\n      }\n\n      if ((index + param_length) < tokens.length) {\n        for (var i = index; i < index + param_length; i++) {\n          var number = tokens[i];\n          if (number.isType(this.NUMBER)) {\n            params[params.length] = number.text;\n          }\n          else {\n            console.error(\"Parameter type is not a number: \" + mode + \",\" + number.text);\n            return;\n          }\n        }\n        var segment;\n        if (this.PARAMS[mode]) {\n          segment = { key: mode, data: params };\n        } else {\n          console.error(\"Unsupported segment type: \" + mode);\n          return;\n        }\n        this.segments.push(segment);\n        index += param_length;\n        token = tokens[index];\n        if (mode == \"M\") mode = \"L\";\n        if (mode == \"m\") mode = \"l\";\n      } else {\n        console.error(\"Path data ended before all parameters were found\");\n      }\n    }\n  }\n\n  tokenize(d) {\n    var tokens = new Array();\n    while (d != \"\") {\n      if (d.match(/^([ \\t\\r\\n,]+)/)) {\n        d = d.substr(RegExp.$1.length);\n      } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n        tokens[tokens.length] = new PathToken(this.COMMAND, RegExp.$1);\n        d = d.substr(RegExp.$1.length);\n      } else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n        tokens[tokens.length] = new PathToken(this.NUMBER, parseFloat(RegExp.$1));\n        d = d.substr(RegExp.$1.length);\n      } else {\n        console.error(\"Unrecognized segment command: \" + d);\n        return null;\n      }\n    }\n    tokens[tokens.length] = new PathToken(this.EOD, null);\n    return tokens;\n  }\n}\n\nexport class RoughPath {\n  constructor(d) {\n    this.d = d;\n    this.parsed = new ParsedPath(d);\n    this._position = [0, 0];\n    this.bezierReflectionPoint = null;\n    this.quadReflectionPoint = null;\n    this._first = null;\n  }\n\n  get segments() {\n    return this.parsed.segments;\n  }\n\n  get closed() {\n    return this.parsed.closed;\n  }\n\n  get linearPoints() {\n    if (!this._linearPoints) {\n      const lp = [];\n      let points = [];\n      for (let s of this.parsed.segments) {\n        let key = s.key.toLowerCase();\n        if (key === 'm' || key === 'z') {\n          if (points.length) {\n            lp.push(points);\n            points = [];\n          }\n          if (key === 'z') {\n            continue;\n          }\n        }\n        if (s.point) {\n          points.push(s.point);\n        }\n      }\n      if (points.length) {\n        lp.push(points);\n        points = [];\n      }\n      this._linearPoints = lp;\n    }\n    return this._linearPoints;\n  }\n\n  get first() {\n    return this._first;\n  }\n\n  set first(v) {\n    this._first = v;\n  }\n\n  setPosition(x, y) {\n    this._position = [x, y];\n    if (!this._first) {\n      this._first = [x, y];\n    }\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  get x() {\n    return this._position[0];\n  }\n\n  get y() {\n    return this._position[1];\n  }\n}\n\nexport class RoughArcConverter {\n  // Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n  // Code adapted from nsSVGPathDataParser.cpp in Mozilla \n  // https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\n  constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n    const radPerDeg = Math.PI / 180;\n    this._segIndex = 0;\n    this._numSegs = 0;\n    if (from[0] == to[0] && from[1] == to[1]) {\n      return;\n    }\n    this._rx = Math.abs(radii[0]);\n    this._ry = Math.abs(radii[1]);\n    this._sinPhi = Math.sin(angle * radPerDeg);\n    this._cosPhi = Math.cos(angle * radPerDeg);\n    var x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n    var y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n    var root;\n    var numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n    if (numerator < 0) {\n      let s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n      this._rx = s;\n      this._ry = s;\n      root = 0;\n    } else {\n      root = (largeArcFlag == sweepFlag ? -1.0 : 1.0) *\n        Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n    }\n    let cxdash = root * this._rx * y1dash / this._ry;\n    let cydash = -root * this._ry * x1dash / this._rx;\n    this._C = [0, 0];\n    this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n    this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n    this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n    let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n    if ((!sweepFlag) && (dtheta > 0)) {\n      dtheta -= 2 * Math.PI;\n    } else if (sweepFlag && (dtheta < 0)) {\n      dtheta += 2 * Math.PI;\n    }\n    this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n    this._delta = dtheta / this._numSegs;\n    this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    this._from = from;\n  }\n\n  getNextSegment() {\n    var cp1, cp2, to;\n    if (this._segIndex == this._numSegs) {\n      return null;\n    }\n    let cosTheta1 = Math.cos(this._theta);\n    let sinTheta1 = Math.sin(this._theta);\n    let theta2 = this._theta + this._delta;\n    let cosTheta2 = Math.cos(theta2);\n    let sinTheta2 = Math.sin(theta2);\n\n    to = [\n      this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n      this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n    ];\n    cp1 = [\n      this._from[0] + this._T * (- this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n      this._from[1] + this._T * (- this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n    ];\n    cp2 = [\n      to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n      to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n    ];\n\n    this._theta = theta2;\n    this._from = [to[0], to[1]];\n    this._segIndex++;\n\n    return {\n      cp1: cp1,\n      cp2: cp2,\n      to: to\n    };\n  }\n\n  calculateVectorAngle(ux, uy, vx, vy) {\n    let ta = Math.atan2(uy, ux);\n    let tb = Math.atan2(vy, vx);\n    if (tb >= ta)\n      return tb - ta;\n    return 2 * Math.PI - (ta - tb);\n  }\n}\n\nexport class PathFitter {\n  constructor(sets, closed) {\n    this.sets = sets;\n    this.closed = closed;\n  }\n\n  fit(simplification) {\n    let outSets = [];\n    for (const set of this.sets) {\n      let length = set.length;\n      let estLength = Math.floor(simplification * length);\n      if (estLength < 5) {\n        if (length <= 5) {\n          continue;\n        }\n        estLength = 5;\n      }\n      outSets.push(this.reduce(set, estLength));\n    }\n\n    let d = '';\n    for (const set of outSets) {\n      for (let i = 0; i < set.length; i++) {\n        let point = set[i];\n        if (i === 0) {\n          d += 'M' + point[0] + \",\" + point[1];\n        } else {\n          d += 'L' + point[0] + \",\" + point[1];\n        }\n      }\n      if (this.closed) {\n        d += 'z ';\n      }\n    }\n    return d;\n  }\n\n  distance(p1, p2) {\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n  }\n\n  reduce(set, count) {\n    if (set.length <= count) {\n      return set;\n    }\n    let points = set.slice(0);\n    while (points.length > count) {\n      let areas = [];\n      let minArea = -1;\n      let minIndex = -1;\n      for (let i = 1; i < (points.length - 1); i++) {\n        let a = this.distance(points[i - 1], points[i]);\n        let b = this.distance(points[i], points[i + 1]);\n        let c = this.distance(points[i - 1], points[i + 1]);\n        let s = (a + b + c) / 2.0;\n        let area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        areas.push(area);\n        if ((minArea < 0) || (area < minArea)) {\n          minArea = area;\n          minIndex = i;\n        }\n      }\n      if (minIndex > 0) {\n        points.splice(minIndex, 1);\n      } else {\n        break;\n      }\n    }\n    return points;\n  }\n}","import { RoughHachureIterator } from './hachure.js';\nimport { RoughSegmentRelation, RoughSegment } from './segment.js';\nimport { RoughPath, RoughArcConverter, PathFitter } from './path.js';\n\nexport class RoughRenderer {\n  line(x1, y1, x2, y2, o) {\n    let ops = this._doubleLine(x1, y1, x2, y2, o);\n    return { type: 'path', ops };\n  }\n\n  linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n      let ops = [];\n      for (let i = 0; i < (len - 1); i++) {\n        ops = ops.concat(this._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n      }\n      if (close) {\n        ops = ops.concat(this._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n      }\n      return { type: 'path', ops };\n    } else if (len === 2) {\n      return this.line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n  }\n\n  polygon(points, o) {\n    return this.linearPath(points, true, o);\n  }\n\n  rectangle(x, y, width, height, o) {\n    let points = [\n      [x, y], [x + width, y], [x + width, y + height], [x, y + height]\n    ];\n    return this.polygon(points, o);\n  }\n\n  curve(points, o) {\n    let o1 = this._curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    let o2 = this._curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n    return { type: 'path', ops: o1.concat(o2) };\n  }\n\n  ellipse(x, y, width, height, o) {\n    const increment = (Math.PI * 2) / o.curveStepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += this._getOffset(-rx * 0.05, rx * 0.05, o);\n    ry += this._getOffset(-ry * 0.05, ry * 0.05, o);\n    let o1 = this._ellipse(increment, x, y, rx, ry, 1, increment * this._getOffset(0.1, this._getOffset(0.4, 1, o), o), o);\n    let o2 = this._ellipse(increment, x, y, rx, ry, 1.5, 0, o);\n    return { type: 'path', ops: o1.concat(o2) };\n  }\n\n  arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    let cx = x;\n    let cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += this._getOffset(-rx * 0.01, rx * 0.01, o);\n    ry += this._getOffset(-ry * 0.01, ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n      strt += Math.PI * 2;\n      stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n      strt = 0;\n      stp = Math.PI * 2;\n    }\n    let ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    let arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    let o1 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    let o2 = this._arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n    let ops = o1.concat(o2);\n    if (closed) {\n      if (roughClosure) {\n        ops = ops.concat(this._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n        ops = ops.concat(this._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n      } else {\n        ops.push({ op: 'lineTo', data: [cx, cy] });\n        ops.push({ op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n      }\n    }\n    return { type: 'path', ops };\n  }\n\n  hachureFillArc(x, y, width, height, start, stop, o) {\n    let cx = x;\n    let cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += this._getOffset(-rx * 0.01, rx * 0.01, o);\n    ry += this._getOffset(-ry * 0.01, ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n      strt += Math.PI * 2;\n      stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n      strt = 0;\n      stp = Math.PI * 2;\n    }\n    let increment = (stp - strt) / o.curveStepCount;\n    let offset = 1;\n    let xc = [], yc = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n      xc.push(cx + rx * Math.cos(angle));\n      yc.push(cy + ry * Math.sin(angle));\n    }\n    xc.push(cx + rx * Math.cos(stp));\n    yc.push(cy + ry * Math.sin(stp));\n    xc.push(cx);\n    yc.push(cy);\n    return this.hachureFillShape(xc, yc, o);\n  }\n\n  solidFillShape(xCoords, yCoords, o) {\n    let ops = [];\n    if (xCoords && yCoords && xCoords.length && yCoords.length && xCoords.length === yCoords.length) {\n      let offset = o.maxRandomnessOffset || 0;\n      const len = xCoords.length;\n      if (len > 2) {\n        ops.push({ op: 'move', data: [xCoords[0] + this._getOffset(-offset, offset, o), yCoords[0] + this._getOffset(-offset, offset, o)] });\n        for (var i = 1; i < len; i++) {\n          ops.push({ op: 'lineTo', data: [xCoords[i] + this._getOffset(-offset, offset, o), yCoords[i] + this._getOffset(-offset, offset, o)] });\n        }\n      }\n    }\n    return { type: 'fillPath', ops };\n  }\n\n  hachureFillShape(xCoords, yCoords, o) {\n    let ops = [];\n    if (xCoords && yCoords && xCoords.length && yCoords.length) {\n      let left = xCoords[0];\n      let right = xCoords[0];\n      let top = yCoords[0];\n      let bottom = yCoords[0];\n      for (let i = 1; i < xCoords.length; i++) {\n        left = Math.min(left, xCoords[i]);\n        right = Math.max(right, xCoords[i]);\n        top = Math.min(top, yCoords[i]);\n        bottom = Math.max(bottom, yCoords[i]);\n      }\n      const angle = o.hachureAngle;\n      let gap = o.hachureGap;\n      if (gap < 0) {\n        gap = o.strokeWidth * 4;\n      }\n      gap = Math.max(gap, 0.1);\n\n      const radPerDeg = Math.PI / 180;\n      const hachureAngle = (angle % 180) * radPerDeg;\n      const cosAngle = Math.cos(hachureAngle);\n      const sinAngle = Math.sin(hachureAngle);\n      const tanAngle = Math.tan(hachureAngle);\n\n      const it = new RoughHachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n      let rectCoords;\n      while ((rectCoords = it.getNextLine()) != null) {\n        let lines = this._getIntersectingLines(rectCoords, xCoords, yCoords);\n        for (let i = 0; i < lines.length; i++) {\n          if (i < (lines.length - 1)) {\n            let p1 = lines[i];\n            let p2 = lines[i + 1];\n            ops = ops.concat(this._doubleLine(p1[0], p1[1], p2[0], p2[1], o));\n          }\n        }\n      }\n    }\n    return { type: 'fillSketch', ops };\n  }\n\n  hachureFillEllipse(cx, cy, width, height, o) {\n    let ops = [];\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += this._getOffset(-rx * 0.05, rx * 0.05, o);\n    ry += this._getOffset(-ry * 0.05, ry * 0.05, o);\n    let angle = o.hachureAngle;\n    let gap = o.hachureGap;\n    if (gap <= 0) {\n      gap = o.strokeWidth * 4;\n    }\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n    const radPerDeg = Math.PI / 180;\n    let hachureAngle = (angle % 180) * radPerDeg;\n    let tanAngle = Math.tan(hachureAngle);\n    let aspectRatio = ry / rx;\n    let hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n    let sinAnglePrime = aspectRatio * tanAngle / hyp;\n    let cosAnglePrime = 1 / hyp;\n    let gapPrime = gap / ((rx * ry / Math.sqrt((ry * cosAnglePrime) * (ry * cosAnglePrime) + (rx * sinAnglePrime) * (rx * sinAnglePrime))) / rx);\n    let halfLen = Math.sqrt((rx * rx) - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n    for (var xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n      halfLen = Math.sqrt((rx * rx) - (cx - xPos) * (cx - xPos));\n      let p1 = this._affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n      let p2 = this._affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n      ops = ops.concat(this._doubleLine(p1[0], p1[1], p2[0], p2[1], o));\n    }\n    return { type: 'fillSketch', ops };\n  }\n\n  svgPath(path, o) {\n    path = (path || '').replace(/\\n/g, \" \").replace(/(-)/g, \" -\").replace(/(-\\s)/g, \"-\").replace(\"/(\\s\\s)/g\", \" \");\n    let p = new RoughPath(path);\n    if (o.simplification) {\n      let fitter = new PathFitter(p.linearPoints, p.closed);\n      let d = fitter.fit(o.simplification);\n      p = new RoughPath(d);\n    }\n    let ops = [];\n    let segments = p.segments || [];\n    for (let i = 0; i < segments.length; i++) {\n      let s = segments[i];\n      let prev = i > 0 ? segments[i - 1] : null;\n      let opList = this._processSegment(p, s, prev, o);\n      if (opList && opList.length) {\n        ops = ops.concat(opList);\n      }\n    }\n    return { type: 'path', ops };\n  }\n\n  // privates\n\n  _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n    let ops = [];\n    let ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n    let f = null;\n    for (let i = 0; i < 2; i++) {\n      if (i === 0) {\n        ops.push({ op: 'move', data: [path.x, path.y] });\n      } else {\n        ops.push({ op: 'move', data: [path.x + this._getOffset(-ros[0], ros[0], o), path.y + this._getOffset(-ros[0], ros[0], o)] });\n      }\n      f = [x + this._getOffset(-ros[i], ros[i], o), y + this._getOffset(-ros[i], ros[i], o)];\n      ops.push({\n        op: 'bcurveTo', data: [\n          x1 + this._getOffset(-ros[i], ros[i], o), y1 + this._getOffset(-ros[i], ros[i], o),\n          x2 + this._getOffset(-ros[i], ros[i], o), y2 + this._getOffset(-ros[i], ros[i], o),\n          f[0], f[1]\n        ]\n      });\n    }\n    path.setPosition(f[0], f[1]);\n    return ops;\n  }\n\n  _processSegment(path, seg, prevSeg, o) {\n    let ops = [];\n    switch (seg.key) {\n      case 'M':\n      case 'm': {\n        let delta = seg.key === 'm';\n        if (seg.data.length >= 2) {\n          let x = +seg.data[0];\n          let y = +seg.data[1];\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n          let ro = 1 * (o.maxRandomnessOffset || 0);\n          x = x + this._getOffset(-ro, ro, o);\n          y = y + this._getOffset(-ro, ro, o);\n          path.setPosition(x, y);\n          ops.push({ op: 'move', data: [x, y] });\n        }\n        break;\n      }\n      case 'L':\n      case 'l': {\n        let delta = seg.key === 'l';\n        if (seg.data.length >= 2) {\n          let x = +seg.data[0];\n          let y = +seg.data[1];\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n          ops = ops.concat(this._doubleLine(path.x, path.y, x, y, o));\n          path.setPosition(x, y);\n        }\n        break;\n      }\n      case 'H':\n      case 'h': {\n        const delta = seg.key === 'h';\n        if (seg.data.length) {\n          let x = +seg.data[0];\n          if (delta) {\n            x += path.x;\n          }\n          ops = ops.concat(this._doubleLine(path.x, path.y, x, path.y, o));\n          path.setPosition(x, path.y);\n        }\n        break;\n      }\n      case 'V':\n      case 'v': {\n        const delta = seg.key === 'v';\n        if (seg.data.length) {\n          let y = +seg.data[0];\n          if (delta) {\n            y += path.y;\n          }\n          ops = ops.concat(this._doubleLine(path.x, path.y, path.x, y, o));\n          path.setPosition(path.x, y);\n        }\n        break;\n      }\n      case 'Z':\n      case 'z': {\n        if (path.first) {\n          ops = ops.concat(this._doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n          path.setPosition(path.first[0], path.first[1]);\n          path.first = null;\n        }\n        break;\n      }\n      case 'C':\n      case 'c': {\n        const delta = seg.key === 'c';\n        if (seg.data.length >= 6) {\n          let x1 = +seg.data[0];\n          let y1 = +seg.data[1];\n          let x2 = +seg.data[2];\n          let y2 = +seg.data[3];\n          let x = +seg.data[4];\n          let y = +seg.data[5];\n          if (delta) {\n            x1 += path.x;\n            x2 += path.x;\n            x += path.x;\n            y1 += path.y;\n            y2 += path.y;\n            y += path.y;\n          }\n          let ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n          ops = ops.concat(ob);\n          path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n        }\n        break;\n      }\n      case 'S':\n      case 's': {\n        const delta = seg.key === 's';\n        if (seg.data.length >= 4) {\n          let x2 = +seg.data[0];\n          let y2 = +seg.data[1];\n          let x = +seg.data[2];\n          let y = +seg.data[3];\n          if (delta) {\n            x2 += path.x;\n            x += path.x;\n            y2 += path.y;\n            y += path.y;\n          }\n          let x1 = x2;\n          let y1 = y2;\n          let prevKey = prevSeg ? prevSeg.key : \"\";\n          var ref = null;\n          if (prevKey == 'c' || prevKey == 'C' || prevKey == 's' || prevKey == 'S') {\n            ref = path.bezierReflectionPoint;\n          }\n          if (ref) {\n            x1 = ref[0];\n            y1 = ref[1];\n          }\n          let ob = this._bezierTo(x1, y1, x2, y2, x, y, path, o);\n          ops = ops.concat(ob);\n          path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n        }\n        break;\n      }\n      case 'Q':\n      case 'q': {\n        const delta = seg.key === 'q';\n        if (seg.data.length >= 4) {\n          let x1 = +seg.data[0];\n          let y1 = +seg.data[1];\n          let x = +seg.data[2];\n          let y = +seg.data[3];\n          if (delta) {\n            x1 += path.x;\n            x += path.x;\n            y1 += path.y;\n            y += path.y;\n          }\n          let offset1 = 1 * (1 + o.roughness * 0.2);\n          let offset2 = 1.5 * (1 + o.roughness * 0.22);\n          ops.push({ op: 'move', data: [path.x + this._getOffset(-offset1, offset1, o), path.y + this._getOffset(-offset1, offset1, o)] });\n          let f = [x + this._getOffset(-offset1, offset1, o), y + this._getOffset(-offset1, offset1, o)];\n          ops.push({\n            op: 'qcurveTo', data: [\n              x1 + this._getOffset(-offset1, offset1, o), y1 + this._getOffset(-offset1, offset1, o),\n              f[0], f[1]\n            ]\n          });\n          ops.push({ op: 'move', data: [path.x + this._getOffset(-offset2, offset2, o), path.y + this._getOffset(-offset2, offset2, o)] });\n          f = [x + this._getOffset(-offset2, offset2, o), y + this._getOffset(-offset2, offset2, o)];\n          ops.push({\n            op: 'qcurveTo', data: [\n              x1 + this._getOffset(-offset2, offset2, o), y1 + this._getOffset(-offset2, offset2, o),\n              f[0], f[1]\n            ]\n          });\n          path.setPosition(f[0], f[1]);\n          path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n        }\n        break;\n      }\n      case 'T':\n      case 't': {\n        const delta = seg.key === 't';\n        if (seg.data.length >= 2) {\n          let x = +seg.data[0];\n          let y = +seg.data[1];\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n          let x1 = x;\n          let y1 = y;\n          let prevKey = prevSeg ? prevSeg.key : \"\";\n          var ref = null;\n          if (prevKey == 'q' || prevKey == 'Q' || prevKey == 't' || prevKey == 'T') {\n            ref = path.quadReflectionPoint;\n          }\n          if (ref) {\n            x1 = ref[0];\n            y1 = ref[1];\n          }\n          let offset1 = 1 * (1 + o.roughness * 0.2);\n          let offset2 = 1.5 * (1 + o.roughness * 0.22);\n          ops.push({ op: 'move', data: [path.x + this._getOffset(-offset1, offset1, o), path.y + this._getOffset(-offset1, offset1, o)] });\n          let f = [x + this._getOffset(-offset1, offset1, o), y + this._getOffset(-offset1, offset1, o)];\n          ops.push({\n            op: 'qcurveTo', data: [\n              x1 + this._getOffset(-offset1, offset1, o), y1 + this._getOffset(-offset1, offset1, o),\n              f[0], f[1]\n            ]\n          });\n          ops.push({ op: 'move', data: [path.x + this._getOffset(-offset2, offset2, o), path.y + this._getOffset(-offset2, offset2, o)] });\n          f = [x + this._getOffset(-offset2, offset2, o), y + this._getOffset(-offset2, offset2, o)];\n          ops.push({\n            op: 'qcurveTo', data: [\n              x1 + this._getOffset(-offset2, offset2, o), y1 + this._getOffset(-offset2, offset2, o),\n              f[0], f[1]\n            ]\n          });\n          path.setPosition(f[0], f[1]);\n          path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n        }\n        break;\n      }\n      case 'A':\n      case 'a': {\n        const delta = seg.key === 'a';\n        if (seg.data.length >= 7) {\n          let rx = +seg.data[0];\n          let ry = +seg.data[1];\n          let angle = +seg.data[2];\n          let largeArcFlag = +seg.data[3];\n          let sweepFlag = +seg.data[4];\n          let x = +seg.data[5];\n          let y = +seg.data[6];\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n          if (x == path.x && y == path.y) {\n            break;\n          }\n          if (rx == 0 || ry == 0) {\n            ops = ops.concat(this._doubleLine(path.x, path.y, x, y, o));\n            path.setPosition(x, y);\n          } else {\n            let final = null;\n            let ro = o.maxRandomnessOffset || 0;\n            for (let i = 0; i < 1; i++) {\n              let arcConverter = new RoughArcConverter(\n                [path.x, path.y],\n                [x, y],\n                [rx, ry],\n                angle,\n                largeArcFlag ? true : false,\n                sweepFlag ? true : false\n              );\n              let segment = arcConverter.getNextSegment();\n              while (segment) {\n                let ob = this._bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n                ops = ops.concat(ob);\n                segment = arcConverter.getNextSegment();\n              }\n            }\n          }\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return ops;\n  }\n\n  _getOffset(min, max, ops) {\n    return ops.roughness * ((Math.random() * (max - min)) + min);\n  }\n\n  _affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n    var A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n    var B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n    var C = cosAnglePrime;\n    var D = sinAnglePrime;\n    var E = -R * sinAnglePrime;\n    var F = R * cosAnglePrime;\n    return [\n      A + C * x + D * y,\n      B + E * x + F * y\n    ];\n  }\n\n  _doubleLine(x1, y1, x2, y2, o) {\n    const o1 = this._line(x1, y1, x2, y2, o, true, false);\n    const o2 = this._line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n  }\n\n  _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n      offset = Math.sqrt(lengthSq) / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + Math.random() * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = this._getOffset(-midDispX, midDispX, o);\n    midDispY = this._getOffset(-midDispY, midDispY, o);\n    let ops = [];\n    if (move) {\n      if (overlay) {\n        ops.push({\n          op: 'move', data: [\n            x1 + this._getOffset(-halfOffset, halfOffset, o),\n            y1 + this._getOffset(-halfOffset, halfOffset, o)\n          ]\n        });\n      } else {\n        ops.push({\n          op: 'move', data: [\n            x1 + this._getOffset(-offset, offset, o),\n            y1 + this._getOffset(-offset, offset, o)\n          ]\n        });\n      }\n    }\n    if (overlay) {\n      ops.push({\n        op: 'bcurveTo', data: [\n          midDispX + x1 + (x2 - x1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o),\n          midDispY + y1 + (y2 - y1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o),\n          midDispX + x1 + 2 * (x2 - x1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o),\n          midDispY + y1 + 2 * (y2 - y1) * divergePoint + this._getOffset(-halfOffset, halfOffset, o),\n          x2 + this._getOffset(-halfOffset, halfOffset, o),\n          y2 + this._getOffset(-halfOffset, halfOffset, o)\n        ]\n      });\n    } else {\n      ops.push({\n        op: 'bcurveTo', data: [\n          midDispX + x1 + (x2 - x1) * divergePoint + this._getOffset(-offset, offset, o),\n          midDispY + y1 + (y2 - y1) * divergePoint + this._getOffset(-offset, offset, o),\n          midDispX + x1 + 2 * (x2 - x1) * divergePoint + this._getOffset(-offset, offset, o),\n          midDispY + y1 + 2 * (y2 - y1) * divergePoint + this._getOffset(-offset, offset, o),\n          x2 + this._getOffset(-offset, offset, o),\n          y2 + this._getOffset(-offset, offset, o)\n        ]\n      });\n    }\n    return ops;\n  }\n\n  _curve(points, closePoint, o) {\n    const len = points.length;\n    let ops = [];\n    if (len > 3) {\n      const b = [];\n      const s = 1 - o.curveTightness;\n      ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n      for (let i = 1; (i + 2) < len; i++) {\n        const cachedVertArray = points[i];\n        b[0] = [cachedVertArray[0], cachedVertArray[1]];\n        b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n        b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n        b[3] = [points[i + 1][0], points[i + 1][1]];\n        ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n      }\n      if (closePoint && closePoint.length === 2) {\n        let ro = o.maxRandomnessOffset;\n        // TODO: more roughness here?\n        ops.push({ ops: 'lineTo', data: [closePoint[0] + this._getOffset(-ro, ro, o), closePoint[1] + + this._getOffset(-ro, ro, o)] });\n      }\n    } else if (len === 3) {\n      ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n      ops.push({\n        op: 'bcurveTo', data: [\n          points[1][0], points[1][1],\n          points[2][0], points[2][1],\n          points[2][0], points[2][1]]\n      });\n    } else if (len === 2) {\n      ops = ops.concat(this._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n  }\n\n  _ellipse(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const radOffset = this._getOffset(-0.5, 0.5, o) - (Math.PI / 2);\n    const points = [];\n    points.push([\n      this._getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n      this._getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n      points.push([\n        this._getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n        this._getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n      ]);\n    }\n    points.push([\n      this._getOffset(-offset, offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n      this._getOffset(-offset, offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n    ]);\n    points.push([\n      this._getOffset(-offset, offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n      this._getOffset(-offset, offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n    ]);\n    points.push([\n      this._getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n      this._getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n    ]);\n    return this._curve(points, null, o);\n  }\n\n  _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n      points[0][0] + this._getOffset(-offset, offset, o),\n      points[0][1] + this._getOffset(-offset, offset, o),\n    ]);\n    ps.push([\n      points[0][0] + this._getOffset(-offset, offset, o),\n      points[0][1] + this._getOffset(-offset, offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n      ps.push([\n        points[i][0] + this._getOffset(-offset, offset, o),\n        points[i][1] + this._getOffset(-offset, offset, o),\n      ]);\n      if (i === (points.length - 1)) {\n        ps.push([\n          points[i][0] + this._getOffset(-offset, offset, o),\n          points[i][1] + this._getOffset(-offset, offset, o),\n        ]);\n      }\n    }\n    return this._curve(ps, null, o);\n  }\n\n  _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + this._getOffset(-0.1, 0.1, o);\n    const points = [];\n    points.push([\n      this._getOffset(-offset, offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n      this._getOffset(-offset, offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n      points.push([\n        this._getOffset(-offset, offset, o) + cx + rx * Math.cos(angle),\n        this._getOffset(-offset, offset, o) + cy + ry * Math.sin(angle)\n      ]);\n    }\n    points.push([\n      cx + rx * Math.cos(stp),\n      cy + ry * Math.sin(stp)\n    ]);\n    points.push([\n      cx + rx * Math.cos(stp),\n      cy + ry * Math.sin(stp)\n    ]);\n    return this._curve(points, null, o);\n  }\n\n  _getIntersectingLines(lineCoords, xCoords, yCoords) {\n    let intersections = [];\n    var s1 = new RoughSegment(lineCoords[0], lineCoords[1], lineCoords[2], lineCoords[3]);\n    for (var i = 0; i < xCoords.length; i++) {\n      let s2 = new RoughSegment(xCoords[i], yCoords[i], xCoords[(i + 1) % xCoords.length], yCoords[(i + 1) % xCoords.length]);\n      if (s1.compare(s2) == RoughSegmentRelation().INTERSECTS) {\n        intersections.push([s1.xi, s1.yi]);\n      }\n    }\n    return intersections;\n  }\n}","export function RoughSegmentRelation() {\n  return {\n    LEFT: 0,\n    RIGHT: 1,\n    INTERSECTS: 2,\n    AHEAD: 3,\n    BEHIND: 4,\n    SEPARATE: 5,\n    UNDEFINED: 6\n  };\n}\n\nexport class RoughSegment {\n  constructor(px1, py1, px2, py2) {\n    this.RoughSegmentRelationConst = RoughSegmentRelation();\n    this.px1 = px1;\n    this.py1 = py1;\n    this.px2 = px2;\n    this.py2 = py2;\n    this.xi = Number.MAX_VALUE;\n    this.yi = Number.MAX_VALUE;\n    this.a = py2 - py1;\n    this.b = px1 - px2;\n    this.c = px2 * py1 - px1 * py2;\n    this._undefined = ((this.a == 0) && (this.b == 0) && (this.c == 0));\n  }\n\n  isUndefined() {\n    return this._undefined;\n  }\n\n  compare(otherSegment) {\n    if (this.isUndefined() || otherSegment.isUndefined()) {\n      return this.RoughSegmentRelationConst.UNDEFINED;\n    }\n    var grad1 = Number.MAX_VALUE;\n    var grad2 = Number.MAX_VALUE;\n    var int1 = 0, int2 = 0;\n    var a = this.a, b = this.b, c = this.c;\n\n    if (Math.abs(b) > 0.00001) {\n      grad1 = -a / b;\n      int1 = -c / b;\n    }\n    if (Math.abs(otherSegment.b) > 0.00001) {\n      grad2 = -otherSegment.a / otherSegment.b;\n      int2 = -otherSegment.c / otherSegment.b;\n    }\n\n    if (grad1 == Number.MAX_VALUE) {\n      if (grad2 == Number.MAX_VALUE) {\n        if ((-c / a) != (-otherSegment.c / otherSegment.a)) {\n          return this.RoughSegmentRelationConst.SEPARATE;\n        }\n        if ((this.py1 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n          this.xi = this.px1;\n          this.yi = this.py1;\n          return this.RoughSegmentRelationConst.INTERSECTS;\n        }\n        if ((this.py2 >= Math.min(otherSegment.py1, otherSegment.py2)) && (this.py2 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n          this.xi = this.px2;\n          this.yi = this.py2;\n          return this.RoughSegmentRelationConst.INTERSECTS;\n        }\n        return this.RoughSegmentRelationConst.SEPARATE;\n      }\n      this.xi = this.px1;\n      this.yi = (grad2 * this.xi + int2);\n      if (((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) || ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001)) {\n        return this.RoughSegmentRelationConst.SEPARATE;\n      }\n      if (Math.abs(otherSegment.a) < 0.00001) {\n        if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n          return this.RoughSegmentRelationConst.SEPARATE;\n        }\n        return this.RoughSegmentRelationConst.INTERSECTS;\n      }\n      return this.RoughSegmentRelationConst.INTERSECTS;\n    }\n\n    if (grad2 == Number.MAX_VALUE) {\n      this.xi = otherSegment.px1;\n      this.yi = grad1 * this.xi + int1;\n      if (((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) || ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001)) {\n        return this.RoughSegmentRelationConst.SEPARATE;\n      }\n      if (Math.abs(a) < 0.00001) {\n        if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n          return this.RoughSegmentRelationConst.SEPARATE;\n        }\n        return this.RoughSegmentRelationConst.INTERSECTS;\n      }\n      return this.RoughSegmentRelationConst.INTERSECTS;\n    }\n\n    if (grad1 == grad2) {\n      if (int1 != int2) {\n        return this.RoughSegmentRelationConst.SEPARATE;\n      }\n      if ((this.px1 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px1 <= Math.max(otherSegment.py1, otherSegment.py2))) {\n        this.xi = this.px1;\n        this.yi = this.py1;\n        return this.RoughSegmentRelationConst.INTERSECTS;\n      }\n      if ((this.px2 >= Math.min(otherSegment.px1, otherSegment.px2)) && (this.px2 <= Math.max(otherSegment.px1, otherSegment.px2))) {\n        this.xi = this.px2;\n        this.yi = this.py2;\n        return this.RoughSegmentRelationConst.INTERSECTS;\n      }\n      return this.RoughSegmentRelationConst.SEPARATE;\n    }\n\n    this.xi = ((int2 - int1) / (grad1 - grad2));\n    this.yi = (grad1 * this.xi + int1);\n\n    if (((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) || ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001)) {\n      return this.RoughSegmentRelationConst.SEPARATE;\n    }\n    return this.RoughSegmentRelationConst.INTERSECTS;\n  }\n\n  getLength() {\n    return this._getLength(this.px1, this.py1, this.px2, this.py2);\n  }\n\n  _getLength(x1, y1, x2, y2) {\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}","import sketch from 'sketch'\nimport {RoughSketch} from './roughjs'\n\nfunction getPathFromLayer(layer) {\n  const nsbezierpath = NSBezierPath.bezierPathWithPath(layer.sketchObject.pathInFrameWithTransforms())\n\n  return String(nsbezierpath.svgPathAttribute())\n    .replace(/^d=\"/g, '')\n    .replace(/\"$/g, '')\n}\n\nfunction getOptionsFromLayer(layer) {\n  let options = {}\n\n  const fill = (layer.style.fills || []).filter(\n    f => f.sketchObject.isEnabled() && f.fill === 'Color'\n  )[0]\n\n  if (fill) {\n    options.fill = fill.color\n  }\n\n  const border = (layer.style.borders || []).filter(\n    f => f.sketchObject.isEnabled() && f.fillType === 'Color'\n  )[0]\n\n  if (border) {\n    options.stroke = border.color\n    options.strokeWidth = border.thickness\n  } else {\n    options.stroke = '#00000000'\n  }\n\n  return options\n}\n\nexport default function(context) {\n  const document = sketch.getSelectedDocument()\n\n  const selection = document.selectedLayers\n\n  if (selection.isEmpty) {\n    return\n  }\n\n  selection.forEach(layer => {\n    if (layer.type !== 'Shape') {\n      return\n    }\n\n    const rc = new RoughSketch(layer.parent)\n    const newLayer = rc.path(\n      getPathFromLayer(layer),\n      getOptionsFromLayer(layer)\n    )\n\n    newLayer.name = 'Rough ' + layer.name\n\n    // add new layer to parent\n    newLayer.parent = layer.parent\n\n    // hide previous layer\n    layer.hidden = true\n    layer.selected = false\n    // select new one\n    newLayer.selected = true\n  })\n}\n","import { RoughGenerator } from 'roughjs/src/generator' // we hook into the internals to write the wrapper ourselves\nimport sketch from 'sketch'\n\nexport class RoughSketch {\n  constructor(layer, config) {\n    this.layer = sketch.fromNative(layer);\n    this._init(config);\n  }\n\n  _init(config) {\n    this.gen = new RoughGenerator(config, this.layer.frame);\n  }\n\n  get generator() {\n    return this.gen;\n  }\n\n  line(x1, y1, x2, y2, options) {\n    let d = this.gen.line(x1, y1, x2, y2, options);\n    return this.draw(d);\n  }\n\n  rectangle(x, y, width, height, options) {\n    let d = this.gen.rectangle(x, y, width, height, options);\n    return this.draw(d);\n  }\n\n  ellipse(x, y, width, height, options) {\n    let d = this.gen.ellipse(x, y, width, height, options);\n    return this.draw(d);\n  }\n\n  circle(x, y, diameter, options) {\n    let d = this.gen.circle(x, y, diameter, options);\n    return this.draw(d);\n  }\n\n  linearPath(points, options) {\n    let d = this.gen.linearPath(points, options);\n    return this.draw(d);\n  }\n\n  polygon(points, options) {\n    let d = this.gen.polygon(points, options);\n    return this.draw(d);\n  }\n\n  arc(x, y, width, height, start, stop, closed, options) {\n    let d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n    return this.draw(d);\n  }\n\n  curve(points, options) {\n    let d = this.gen.curve(points, options);\n    return this.draw(d);\n  }\n\n  path(d, options) {\n    let drawing = this.gen.path(d, options);\n    return this.draw(drawing);\n  }\n\n  draw(drawable) {\n    let sets = drawable.sets || [];\n    let o = drawable.options || this.gen.defaultOptions;\n\n    // create a group where we will put everything inside\n    const group = new sketch.Group({\n      frame: {\n        x: 0,\n        y: 0,\n        width: this.layer.frame.width,\n        height: this.layer.frame.height\n      }\n    })\n\n    for (let drawing of sets) {\n      let path = null;\n      switch (drawing.type) {\n        case 'path': {\n          let closed = MOPointer.alloc().init()\n          path = sketch.Shape.fromNative(MSShapeGroup.shapeWithBezierPath(\n            MSPath.pathWithBezierPath(SVGPathInterpreter.bezierPathFromCommands_isPathClosed(\n              this._opsToPath(drawing),\n              closed\n            ))\n          ));\n          path.style.borders = [{\n            color: o.stroke,\n            thickness: o.strokeWidth\n          }];\n          path.style.fills = [];\n          path.parent = group\n          break;\n        }\n        case 'fillPath': {\n          let closed = MOPointer.alloc().init()\n          path = sketch.Shape.fromNative(MSShapeGroup.shapeWithBezierPath(\n            MSPath.pathWithBezierPath(SVGPathInterpreter.bezierPathFromCommands_isPathClosed(\n              this._opsToPath(drawing),\n              closed\n            ))\n          ));\n          path.style.borders = [];\n          path.style.fills = [o.fill];\n          path.parent = group\n          break;\n        }\n        case 'fillSketch': {\n          path = this._fillSketch(drawing, o);\n          path.parent = group\n          break;\n        }\n        case 'path2Dfill': {\n          let closed = MOPointer.alloc().init()\n          path = sketch.Shape.fromNative(MSShapeGroup.shapeWithBezierPath(\n            MSPath.pathWithBezierPath(SVGPathInterpreter.bezierPathFromCommands_isPathClosed(\n              drawing.path,\n              closed\n            ))\n          ));\n          path.style.borders = [];\n          path.style.fills = [o.fill];\n          path.parent = group\n          break;\n        }\n        case 'path2Dpattern': {\n          const size = drawing.size;\n          path = new sketch.Group({\n            frame: {\n              x: 0,\n              y: 0,\n              width: this.layer.frame.width,\n              height: this.layer.frame.height\n            }\n          })\n\n          let closed = MOPointer.alloc().init()\n          const mask = sketch.Shape.fromNative(MSShapeGroup.shapeWithBezierPath(\n            MSPath.pathWithBezierPath(SVGPathInterpreter.bezierPathFromCommands_isPathClosed(\n              drawing.path,\n              closed\n            ))\n          ));\n          mask.style.borders = [];\n          mask.style.fills = [];\n\n          mask.parent = path;\n\n          const hash = this._fillSketch(drawing, o);\n          hash.parent = path\n\n          mask.sketchObject.hasClippingMask = true\n          mask.sketchObject.clippingMaskMode = 0\n          path.parent = group\n          path.adjustToFit()\n\n          hash.frame = {\n            width: hash.frame.width,\n            height: hash.frame.height,\n            x: 0,\n            y: 0\n          }\n          break;\n        }\n      }\n    }\n\n    group.adjustToFit()\n    return group;\n  }\n\n  _fillSketch(drawing, o) {\n    let fweight = o.fillWeight;\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n    let closed = MOPointer.alloc().init()\n    let path = sketch.Shape.fromNative(MSShapeGroup.shapeWithBezierPath(\n      MSPath.pathWithBezierPath(SVGPathInterpreter.bezierPathFromCommands_isPathClosed(\n        this._opsToPath(drawing),\n        closed\n      ))\n    ));\n    path.style.borders = [{\n      color: o.fill,\n      thickness: fweight\n    }];\n    path.style.fills = [];\n    return path;\n  }\n\n  _opsToPath(drawing) {\n    return this.gen.opsToPath(drawing);\n  }\n}\n","module.exports = require(\"sketch\");"],"sourceRoot":""}